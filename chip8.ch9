# Define our variables.
@V0
@V1
@V2
@V3
@V4
@V5
@V6
@V7
@V8
@V9
@VA
@VB
@VC
@VD
@VE
@VF
@PCL
@PCH
@SPL
@SPH
@IL
@IH
@Sound
@Delay


###---START LOADER---###

# This first part cannot use labels since we haven't copied the binary
# to the correct base address yet.
# Copy the emulator program to the base addr 0xA000
# BC = src, DE = tgt
# Remember our ROM starts at 0x325

21 0339
31 A000

# Read from [BC]
MOV.HL.BC
EC

# Write to [ED]
MOV.HL.DE
MOV.(HL).A

# Inc the registers.
A8
INX.DE

# Loop unless B = 0x40
MOV.A.B
CMPI 40
BF F5

# When done, jump to the new start of the ROM.
JMP A000

###---END LOADER---###

# Now enter CHIP8 Emulator land.


# -- Load ROM

# First job = load the ROM from stdin into memory at 0x200.
# Read number of bytes in ROM.  MSB then LSB
# e.g. if the ROM is 1283 bytes, enter 0x05 and then 0x03
# Store ROM size in BC
E0
79
E0
F9
17

# Now read in bytes until BC hits 0.
# Note there's no 16-bit DEC, so we have to do 2 loops.
LDX.HL 0200

load_rom_loop:
E0
MOV.(HL).A
INX.HL

# DEC C
17

# If no borrow, loop.
7F $load_rom_loop

# If carry, DEC B
07

# If no borrow, loop.
7F $load_rom_loop

# -- Initialization Routine

# Init SP to 0xEFE
90 0E
LDX.HL $SPH
MOV.(HL).A
90 FE
LDX.HL $SPL
MOV.(HL).A

# Init PC to 0x200
90 02
LDX.HL $PCH
MOV.(HL).A
90 00
LDX.HL $PCL
MOV.(HL).A

CLRSCR

########################
# -- Main Loop
########################

main_loop:

# Load opcode into BC
CALL $load_opcode

# Switch on first byte.
MOV.A.B
CMPI 00
JMPZ $first_byte_00

# 0x1NNN
MOV.A.B
ANDI F0
XORI 10
JMPZ $goto_nnn

# 0x2NNN
MOV.A.B
ANDI F0
XORI 20
JMPZ $subr_call

# 0x3XNN
MOV.A.B
ANDI F0
XORI 30
JMPZ $op_skip_eq_const

# 0x4XNN
MOV.A.B
ANDI F0
XORI 40
JMPZ $op_skip_neq_const

# 0x5XNN
MOV.A.B
ANDI F0
XORI 50
JMPZ $op_skip_if_regs_eq

# 0x6XNN
MOV.A.B
ANDI F0
XORI 60
JMPZ $op_set_vx

# 0x7XNN
MOV.A.B
ANDI F0
XORI 70
JMPZ $op_add_to_vx

# 0x8XNN
MOV.A.B
ANDI F0
XORI 80
JMPZ $first_byte_8x

# TODO: More ops.

# 0xANNN
MOV.A.B
ANDI F0
XORI A0
JMPZ $op_set_i

# TODO: More ops.

# 0xDNNN
MOV.A.B
ANDI F0
XORI D0
JMPZ $op_draw_sprite

# 0xE???
MOV.A.B
ANDI F0
XORI E0
JMPZ $first_byte_ex

# 0xF???
MOV.A.B
ANDI F0
XORI F0
JMPZ $first_byte_fx

FIRE

first_byte_00:

# Switch on second byte.
MOV.A.C
CMPI E0
JMPZ $clear_screen

CMPI EE
JMPZ $subr_return

FIRE

first_byte_8x:

MOV.A.C
ANDI 0F
CMPI 00
JMPZ $op_set_vx_vy

# TODO: More

MOV.A.C
ANDI 0F
CMPI 04
JMPZ $op_add_vx_vy

# TODO: More

FIRE

first_byte_ex:

# TODO: Implement.
JMP $op_done

FIRE

first_byte_fx:

# Switch on second byte

# TODO: More

MOV.A.C
CMPI 1E
JMPZ $op_add_reg_to_i

# TODO: More

FIRE

clear_screen:
CLRSCR
JMP $op_done

subr_return:

CALL $return_from_subroutine
JMP $op_done

goto_nnn:

CALL $jump_to_address
JMP $op_done

subr_call:

CALL $call_subroutine
JMP $op_done

op_skip_eq_const:

CALL $skip_if_eq_const
JMP $op_done

op_skip_neq_const:

CALL $skip_if_neq_const
JMP $op_done

op_skip_if_regs_eq:

CALL $skip_if_regs_eq
JMP $op_done

op_set_vx:

MOV.A.B
MOV.B.C
CALL $set_vx
JMP $op_done

op_add_to_vx:

CALL $add_to_vx
JMP $op_done

op_set_i:

CALL $set_i
JMP $op_done

op_draw_sprite:

CALL $draw_sprite
JMP $op_done

op_add_reg_to_i:

CALL $add_reg_to_i
JMP $op_done

op_set_vx_vy:

CALL $set_vx_vy
JMP $op_done

op_add_vx_vy:

CALL $add_vx_vy
JMP $op_done

op_done:

JMP $main_loop

# -- END

########################
# -- Load Opcode
# Loads opcode into BC.
# Does not preserve any registers.
########################

load_opcode:

# Load CHIP8 PC into DE
LDX.HL $PCH
MOV.D.(HL)
LDX.HL $PCL
MOV.E.(HL)

# Load opcode into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)
INX.HL

# Store back the modified CHIP8 PC which is currently in HL.
MOV.D.H
MOV.E.L
LDX.HL $PCH
MOV.(HL).D
LDX.HL $PCL
MOV.(HL).E

RET

# -- END

########################
# -- Return from Subroutine
# Increment SP by two and load values into PC.
# Does not preserve any registers.
########################

return_from_subroutine:

# Load CHIP8 SP into DE
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)

# Increment by 2.
INX.DE
INX.DE

# Load bytes into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)

# Store new SP

LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Store new PC

LDX.HL $PCH
MOV.(HL).B
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

########################
# -- Jump to address
# Unconditional jump, set PC equal to lower 3 nibbles of BC.
########################

jump_to_address:

# High byte is in B, need to AND with 0x0F first.
MOV.A.B
ANDI 0F
LDX.HL $PCH
MOV.(HL).A

# Low byte is in C, just set directly.
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

########################
# -- Call Subroutine
# Push PC, Jump.
# Jump address is in BC so don't touch BC!
########################

call_subroutine:

# Copy PC onto Stack.
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)
LDX.HL $PCH
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
DEC.E
LDX.HL $PCL
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
DEC.E

# Store new Stack pointer.
LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Jump to address in BC.
CALL $jump_to_address

RET

# -- END

########################
# -- Load VX Address
# Loads address for the register specified in lower nibble of A into HL.
########################

load_vx_addr:

ANDI 0F

LDX.HL $V0
CMPI 00
JMPZ $load_vx_addr_done

LDX.HL $V1
CMPI 01
JMPZ $load_vx_addr_done

LDX.HL $V2
CMPI 02
JMPZ $load_vx_addr_done

LDX.HL $V3
CMPI 03
JMPZ $load_vx_addr_done

LDX.HL $V4
CMPI 05
JMPZ $load_vx_addr_done

LDX.HL $V5
CMPI 05
JMPZ $load_vx_addr_done

LDX.HL $V6
CMPI 06
JMPZ $load_vx_addr_done

LDX.HL $V7
CMPI 07
JMPZ $load_vx_addr_done

LDX.HL $V8
CMPI 08
JMPZ $load_vx_addr_done

LDX.HL $V9
CMPI 09
JMPZ $load_vx_addr_done

LDX.HL $VA
CMPI 0A
JMPZ $load_vx_addr_done

LDX.HL $VB
CMPI 0B
JMPZ $load_vx_addr_done

LDX.HL $VC
CMPI 0C
JMPZ $load_vx_addr_done

LDX.HL $VD
CMPI 0D
JMPZ $load_vx_addr_done

LDX.HL $VE
CMPI 0E
JMPZ $load_vx_addr_done

LDX.HL $VF
CMPI 0F
JMPZ $load_vx_addr_done

FIRE

load_vx_addr_done:

RET

# -- END

########################
# -- Set VX
# Register number should be in lower nibble of A
# Target value should be in B
########################

set_vx:

CALL $load_vx_addr
MOV.(HL).B

RET

# -- END

########################
# -- Get VX
# Register number should be in lower nibble of A
# Value will be loaded into B
########################

get_vx:

CALL $load_vx_addr
MOV.B.(HL)

RET

# -- END

########################
# -- Skip instruction
# Moves PC forward by 2
########################

skip_instruction:

LDX.HL $PCH
MOV.D.(HL)
LDX.HL $PCL
MOV.E.(HL)
INX.DE
INX.DE
MOV.(HL).E
LDX.HL $PCH
MOV.(HL).D

RET

# -- END

########################
# -- Skip if Equal Constant
# Parse opcode 0x3XNN in BC
########################

skip_if_eq_const:

MOV.A.B
CALL $get_vx
MOV.A.C
CMP.B
NJMPNZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- Skip if NOT Equal Constant
# Parse opcode 0x4XNN in BC
########################

skip_if_neq_const:

MOV.A.B
CALL $get_vx
MOV.A.C
CMP.B
NJMPZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- Skip if Registers equal
# Parse opcode 0x5XY0 in BC
########################

skip_if_regs_eq:

CALL $load_vxy

# Now VX is in D and VY is in E
MOV.A.E
CMP.D
NJMPNZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- LOAD VXY
# For BC = 0x?XY?
# Loads VX into D, VY into E.
# Leaves X in B, Y is destroyed.
########################

load_vxy:

# Get VX into D.
MOV.A.B
CALL $get_vx
MOV.D.B

# Need to shift C right by 4 to get the Y register.
# Do this by shifting LEFT 4 times, and shifting carry bits into B.
# We can left-shift just by doubling.
LDI.B 00

CALL $shift_left_16
CALL $shift_left_16
CALL $shift_left_16
CALL $shift_left_16

MOV.A.B
CALL $get_vx
MOV.E.B
MOV.B.A

RET

# -- END

########################
# -- Get I
# Set 16-bit register I into BC. (only 12bit)
########################

get_i:

LDX.HL $IH
MOV.B.(HL)
LDX.HL $IL
MOV.C.(HL)
MOV.A.B
ANDI 0F
MOV.B.A

RET

# -- END

########################
# -- Set I
# Set 16-bit register I with lower 3 nibbles of BC.
########################

set_i:

# Zero out top nibble.
MOV.A.B
ANDI 0F
MOV.B.A

LDX.HL $IH
MOV.(HL).B
LDX.HL $IL
MOV.(HL).C

RET

# -- END

########################
# -- Add to VX
# Args come in as 0x7XNN
########################

add_to_vx:

# Store off X in D because we get a value back in B
MOV.D.B

MOV.A.D
CALL $get_vx
MOV.A.B
ADD.C
MOV.B.C
MOV.A.D
CALL $set_vx

RET

# -- END

########################
# -- Set VX = VY
# Args come in as 0x8XY0
########################

set_vx_vy:

CALL $load_vxy

MOV.A.B
MOV.B.E
CALL $set_vx

RET

# -- END

########################
# -- Add VX to VY
# Args come in as 0x8XY4
########################

add_vx_vy:

CALL $load_vxy

# Store off X, left in B.
PUSH.B

MOV.A.D
ADD.E

# Set carry
NJMPC 04

# No carry
LDI.B 00
NJMP 02

# Carry
LDI.B 01

LDI.A 0F
CALL $set_vx

# Store val.
POP.A
MOV.B.E
CALL $set_vx

RET

# -- END

########################
# -- Shift Left 16
# Args:
#  BC = value to shift.
########################

shift_left_16:

# Double C
MOV.A.C
ADD.A
MOV.C.A

JMPC $shift_left_16_carry

# No Carry
# Double B, don't add 1.
MOV.A.B
ADD.A
MOV.B.A
RET

# Carry
shift_left_16_carry:
# Double B, add 1.
MOV.A.B
ADD.A
ADDI 01
MOV.B.A
RET

#-- END

########################
# -- Draw Sprite
# BC = 0xDXYN
# Draws sprite at (X, Y) with height N.
# Sprite comes from register I.
# Sprite pixels are XORed with screen pixels.
# VF is set to 1 if any pixels flip from on to off, and 0 otherwise.
########################

draw_sprite:

# Store off N for now.
MOV.A.C
ANDI 0F
PUSH.A

# Load X, Y -> D, E
CALL $load_vxy

# Use BC as pixel ptr.
LDX.HL $IH
MOV.B.(HL)
LDX.HL $IL
MOV.C.(HL)

draw_y_loop:

# Get Pixels -> A
MOV.HL.BC
MOV.A.(HL)

# Store BC (pixel ptr)
PUSH.BC

# TODO: XOR logic.

# For CHIP9 draw call we need X in C, Y in B and pixels in A.
MOV.C.D
MOV.B.E
DRAW

# Loop counter.
POP.BC
INX.BC
INC.E
POP.A
DEC.A
NJMPZ 04
PUSH.A
JMP $draw_y_loop

# TODO: Set VF

RET

# -- END

########################
# -- Add reg to I
# BC = 0xFX1E
# Sets VF to 1 if I overflowed 12 bits.
########################

add_reg_to_i:

# VX -> E
MOV.A.B
CALL $get_vx
MOV.E.B

# I -> BC
CALL $get_i

# Add.
MOV.A.E
ADDX.BC

# Check overflow.
MOV.A.B
ANDI F0
# Save off answer -> DE
MOV.D.B
MOV.E.C
NJMPZ 04

# Overflow
LDI.B 01
NJMP 02

# No Overflow
LDI.B 00

# Store.
LDI.A 0F
CALL $set_vx
MOV.B.D
MOV.C.E
CALL $set_i

RET

# --

# HCF
FIRE
