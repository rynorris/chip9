# Define our variables.
@V0
@V1
@V2
@V3
@V4
@V5
@V6
@V7
@V8
@V9
@VA
@VB
@VC
@VD
@VE
@VF
@PCL
@PCH
@SPL
@SPH
@Delay
@Sound


###---START LOADER---###

# This first part cannot use labels since we haven't copied the binary
# to the correct base address yet.
# Copy the emulator program to the base addr 0xA000
# BC = src, DE = tgt
# Remember our ROM starts at 0x325

21 0339
31 A000

# Read from [BC]
MOV.HL.BC
EC

# Write to [ED]
MOV.HL.DE
MOV.(HL).A

# Inc the registers.
A8
INX.DE

# Loop unless B = 0x40
MOV.A.B
CMPI 40
BF F5

# When done, jump to the new start of the ROM.
JMP A000

###---END LOADER---###

# Now enter CHIP8 Emulator land.


# -- Load ROM

# First job = load the ROM from stdin into memory at 0x200.
# Read number of bytes in ROM.  MSB then LSB
# e.g. if the ROM is 1283 bytes, enter 0x05 and then 0x03
# Store ROM size in BC
E0
79
E0
F9
17

# Now read in bytes until BC hits 0.
# Note there's no 16-bit DEC, so we have to do 2 loops.
LDX.HL 0200

load_rom_loop:
E0
MOV.(HL).A
INX.HL

# DEC C
17

# If no borrow, loop.
7F $load_rom_loop

# If carry, DEC B
07

# If no borrow, loop.
7F $load_rom_loop

# -- Initialization Routine

# Init SP to 0xEFE
90 0E
LDX.HL $SPH
MOV.(HL).A
90 FE
LDX.HL $SPL
MOV.(HL).A

# Init PC to 0x200
90 02
LDX.HL $PCH
MOV.(HL).A
90 00
LDX.HL $PCL
MOV.(HL).A

# -- Main Loop

main_loop:

# Load opcode into BC
CALL $load_opcode

# Switch on first byte.
MOV.A.B
CMPI 00
JMPZ $first_byte_00

# 0x1NNN
CMPI 20
JMPN $goto_nnn

# 0x2NNN
CMPI 30
JMPN $subr_call

# TODO: More ops.
FIRE

first_byte_00:

# Switch on second byte.
MOV.A.C
CMPI E0
JMPZ $clear_screen

CMPI EE
JMPZ $subr_return

FIRE

clear_screen:
CLRSCR
JMP $op_done

subr_return:

CALL $return_from_subroutine
JMP $op_done

goto_nnn:

CALL $jump_to_address
JMP $op_done

subr_call:

CALL $call_subroutine
JMP $op_done

op_done:

JMP $main_loop

# -- END

# -- Load Opcode
# Loads opcode into BC.
# Does not preserve any registers.

load_opcode:

# Load CHIP8 PC into DE
LDX.HL $PCH
MOV.D.(HL)
LDX.HL $PCL
MOV.E.(HL)

# Load opcode into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)
INX.HL

# Store back the modified CHIP8 PC which is currently in HL.
MOV.D.H
MOV.E.L
LDX.HL $PCH
MOV.(HL).D
LDX.HL $PCL
MOV.(HL).E

RET

# -- END

# -- Return from Subroutine
# Increment SP by two and load values into PC.
# Does not preserve any registers.

return_from_subroutine:

# Load CHIP8 SP into DE
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)

# Increment by 2.
INX.DE
INX.DE

# Load bytes into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)

# Store new SP

LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Store new PC

LDX.HL $PCH
MOV.(HL).B
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

# -- Jump to address
# Unconditional jump, set PC equal to lower 3 nibbles of BC.

jump_to_address:

# High byte is in B, need to AND with 0x0F first.
MOV.A.B
ANDI 0F
LDX.HL $PCH
MOV.(HL).A

# Low byte is in C, just set directly.
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

# -- Call Subroutine
# Push PC, Jump.
# Jump address is in BC so don't touch BC!

call_subroutine:

# Copy PC onto Stack.
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)
LDX.HL $PCH
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
INX.DE
LDX.HL $PCL
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
INX.DE

# Store new Stack pointer.
LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Jump to address in BC.
CALL $jump_to_address

RET

# -- END

# HCF
FIRE
