# Define our variables.
@V0
@V1
@V2
@V3
@V4
@V5
@V6
@V7
@V8
@V9
@VA
@VB
@VC
@VD
@VE
@VF
@PCL
@PCH
@SPL
@SPH
@Delay
@Sound


###---START LOADER---###

# This first part cannot use labels since we haven't copied the binary
# to the correct base address yet.
# Copy the emulator program to the base addr 0xA000
# BC = src, DE = tgt
# Remember our ROM starts at 0x325

21 0339
31 A000

# Read from [BC]
MOV.HL.BC
EC

# Write to [ED]
MOV.HL.DE
MOV.(HL).A

# Inc the registers.
A8
INX.DE

# Loop unless B = 0x40
MOV.A.B
CMPI 40
BF F5

# When done, jump to the new start of the ROM.
JMP A000

###---END LOADER---###

# Now enter CHIP8 Emulator land.


# -- Load ROM

# First job = load the ROM from stdin into memory at 0x200.
# Read number of bytes in ROM.  MSB then LSB
# e.g. if the ROM is 1283 bytes, enter 0x05 and then 0x03
# Store ROM size in BC
E0
79
E0
F9
17

# Now read in bytes until BC hits 0.
# Note there's no 16-bit DEC, so we have to do 2 loops.
LDX.HL 0200

load_rom_loop:
E0
MOV.(HL).A
INX.HL

# DEC C
17

# If no borrow, loop.
7F $load_rom_loop

# If carry, DEC B
07

# If no borrow, loop.
7F $load_rom_loop

# -- Initialization Routine

# Init SP to 0xEFE
90 0E
LDX.HL $SPH
MOV.(HL).A
90 FE
LDX.HL $SPL
MOV.(HL).A

# Init PC to 0x200
90 02
LDX.HL $PCH
MOV.(HL).A
90 00
LDX.HL $PCL
MOV.(HL).A

########################
# -- Main Loop
########################

main_loop:

# Load opcode into BC
CALL $load_opcode

# Switch on first byte.
MOV.A.B
CMPI 00
JMPZ $first_byte_00

# 0x1NNN
MOV.A.B
ANDI F0
XORI 10
JMPZ $goto_nnn

# 0x2NNN
MOV.A.B
ANDI F0
XORI 20
JMPZ $subr_call

# 0x3XNN
MOV.A.B
ANDI F0
XORI 30
JMPZ $op_skip_eq_const

# 0x4XNN
MOV.A.B
ANDI F0
XORI 40
JMPZ $op_skip_neq_const

# 0x5XNN
MOV.A.B
ANDI F0
XORI 50
JMPZ $op_skip_if_regs_eq

# 0x6XNN
MOV.A.B
ANDI F0
XORI 60
JMPZ $op_set_vx

# TODO: More ops.
FIRE

first_byte_00:

# Switch on second byte.
MOV.A.C
CMPI E0
JMPZ $clear_screen

CMPI EE
JMPZ $subr_return

FIRE

clear_screen:
CLRSCR
JMP $op_done

subr_return:

CALL $return_from_subroutine
JMP $op_done

goto_nnn:

CALL $jump_to_address
JMP $op_done

subr_call:

CALL $call_subroutine
JMP $op_done

op_skip_eq_const:

CALL $skip_if_eq_const
JMP $op_done

op_skip_neq_const:

CALL $skip_if_neq_const
JMP $op_done

op_skip_if_regs_eq:

CALL $skip_if_regs_eq
JMP $op_done

op_set_vx:

MOV.A.B
MOV.B.C
CALL $set_vx
JMP $op_done

op_done:

JMP $main_loop

# -- END

########################
# -- Load Opcode
# Loads opcode into BC.
# Does not preserve any registers.
########################

load_opcode:

# Load CHIP8 PC into DE
LDX.HL $PCH
MOV.D.(HL)
LDX.HL $PCL
MOV.E.(HL)

# Load opcode into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)
INX.HL

# Store back the modified CHIP8 PC which is currently in HL.
MOV.D.H
MOV.E.L
LDX.HL $PCH
MOV.(HL).D
LDX.HL $PCL
MOV.(HL).E

RET

# -- END

########################
# -- Return from Subroutine
# Increment SP by two and load values into PC.
# Does not preserve any registers.
########################

return_from_subroutine:

# Load CHIP8 SP into DE
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)

# Increment by 2.
INX.DE
INX.DE

# Load bytes into BC
MOV.HL.DE
MOV.B.(HL)
INX.HL
MOV.C.(HL)

# Store new SP

LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Store new PC

LDX.HL $PCH
MOV.(HL).B
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

########################
# -- Jump to address
# Unconditional jump, set PC equal to lower 3 nibbles of BC.
########################

jump_to_address:

# High byte is in B, need to AND with 0x0F first.
MOV.A.B
ANDI 0F
LDX.HL $PCH
MOV.(HL).A

# Low byte is in C, just set directly.
LDX.HL $PCL
MOV.(HL).C

RET

# -- END

########################
# -- Call Subroutine
# Push PC, Jump.
# Jump address is in BC so don't touch BC!
########################

call_subroutine:

# Copy PC onto Stack.
LDX.HL $SPH
MOV.D.(HL)
LDX.HL $SPL
MOV.E.(HL)
LDX.HL $PCH
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
INX.DE
LDX.HL $PCL
MOV.A.(HL)
MOV.HL.DE
MOV.(HL).A
INX.DE

# Store new Stack pointer.
LDX.HL $SPH
MOV.(HL).D
LDX.HL $SPL
MOV.(HL).E

# Jump to address in BC.
CALL $jump_to_address

RET

# -- END

########################
# -- Load VX Address
# Loads address for the register specified in lower nibble of A into HL.
########################

load_vx_addr:

ANDI 0F

LDX.HL $V0
CMPI 00
JMPZ $load_vx_addr_done

LDX.HL $V1
CMPI 01
JMPZ $load_vx_addr_done

LDX.HL $V2
CMPI 02
JMPZ $load_vx_addr_done

LDX.HL $V3
CMPI 03
JMPZ $load_vx_addr_done

LDX.HL $V4
CMPI 05
JMPZ $load_vx_addr_done

LDX.HL $V5
CMPI 05
JMPZ $load_vx_addr_done

LDX.HL $V6
CMPI 06
JMPZ $load_vx_addr_done

LDX.HL $V7
CMPI 07
JMPZ $load_vx_addr_done

LDX.HL $V8
CMPI 08
JMPZ $load_vx_addr_done

LDX.HL $V9
CMPI 09
JMPZ $load_vx_addr_done

LDX.HL $VA
CMPI 0A
JMPZ $load_vx_addr_done

LDX.HL $VB
CMPI 0B
JMPZ $load_vx_addr_done

LDX.HL $VC
CMPI 0C
JMPZ $load_vx_addr_done

LDX.HL $VD
CMPI 0D
JMPZ $load_vx_addr_done

LDX.HL $VE
CMPI 0E
JMPZ $load_vx_addr_done

LDX.HL $VF
CMPI 0F
JMPZ $load_vx_addr_done

FIRE

load_vx_addr_done:

RET

# -- END

########################
# -- Set VX
# Register number should be in lower nibble of A
# Target value should be in B
########################

set_vx:

CALL $load_vx_addr
MOV.(HL).B

RET

# -- END

########################
# -- Get VX
# Register number should be in lower nibble of A
# Value will be loaded into B
########################

get_vx:

CALL $load_vx_addr
MOV.B.(HL)

RET

# -- END

########################
# -- Skip instruction
# Moves PC forward by 2
########################

skip_instruction:

LDX.HL $PCH
MOV.D.(HL)
LDX.HL $PCL
MOV.E.(HL)
INX.DE
INX.DE
MOV.(HL).E
LDX.HL $PCH
MOV.(HL).D

RET

# -- END

########################
# -- Skip if Equal Constant
# Parse opcode 0x3XNN in BC
########################

skip_if_eq_const:

MOV.A.B
CALL $get_vx
MOV.A.C
CMP.B
NJMPNZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- Skip if NOT Equal Constant
# Parse opcode 0x4XNN in BC
########################

skip_if_neq_const:

MOV.A.B
CALL $get_vx
MOV.A.C
CMP.B
NJMPZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- Skip if Registers equal
# Parse opcode 0x5XY0 in BC
########################

skip_if_regs_eq:

# Get VX into D.
MOV.A.B
CALL $get_vx
MOV.D.B

# Need to shift C right by 4 to get the Y register.
# Do this by shifting LEFT 4 times, and shifting carry bits into B.
# We can left-shift just by doubling.
LDI.B 00

CALL $shift_left_16
CALL $shift_left_16
CALL $shift_left_16
CALL $shift_left_16

MOV.A.B
CALL $get_vx

# Now VX is in D and VY is in B
MOV.A.B
CMP.D
NJMPNZ 03
CALL $skip_instruction

RET

# -- END

########################
# -- Shift Left 16
# Args:
#  BC = value to shift.
########################

shift_left_16:

# Double C
MOV.A.C
ADD.A
MOV.C.A

JMPC $shift_left_16_carry

# No Carry
# Double B, don't add 1.
MOV.A.B
ADD.A
MOV.B.A
RET

# Carry
shift_left_16_carry:
# Double B, add 1.
MOV.A.B
ADD.A
ADDI 01
MOV.B.A
RET

#-- END

# HCF
FIRE
